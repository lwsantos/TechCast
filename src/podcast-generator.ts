import { GoogleGenerativeAI } from '@google/generative-ai';
import { promises as fs } from 'fs';
import path from 'path';
import dotenv from 'dotenv';
import { sendTelegramMessage } from './telegram-provider';
import { getTodayISODate, getTodayPromptDate } from './utils/date-helper';

// Carregar vari√°veis de ambiente
dotenv.config();

interface Article {
  titulo: string;
  url: string;
  dataPublicacao: string;
  autor: string;
  conteudo: string;
  tituloTraduzido?: string;
  conteudoTraduzido?: string;
}

interface TranslatedArticle extends Article {
  tituloTraduzido: string;
  conteudoTraduzido: string;
}

class PodcastGenerator {
  private genAI: GoogleGenerativeAI;
  private model: any;
  private apiKey: string;

  constructor() {
    this.apiKey = process.env.GOOGLE_API_KEY || '';
    if (!this.apiKey) {
      throw new Error('GOOGLE_API_KEY n√£o est√° configurada. Configure a vari√°vel de ambiente com sua API Key do Google AI Studio.');
    }

    this.genAI = new GoogleGenerativeAI(this.apiKey);
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });
  }

  private async loadArticles(): Promise<TranslatedArticle[]> {
    try {
      const today = getTodayISODate();
      const inputPath = path.join(process.cwd(), 'output', 'news', `news_${today}.json`);
      console.log(`üìñ Carregando artigos de: ${inputPath}`);
      
      const fileContent = await fs.readFile(inputPath, 'utf-8');
      const data = JSON.parse(fileContent);
      
      // Verificar se √© o formato esperado (array direto ou objeto com 'artigos')
      const articles = Array.isArray(data) ? data : data.artigos || [];
      
      // Filtrar apenas artigos que t√™m tradu√ß√£o
      const translatedArticles = articles.filter((article: any) => 
        article.tituloTraduzido && article.conteudoTraduzido
      ) as TranslatedArticle[];
      
      console.log(`‚úÖ ${translatedArticles.length} artigos traduzidos carregados`);
      return translatedArticles;
    } catch (error) {
      console.error(`‚ùå Erro ao carregar artigos para gerar o roteiro:`, error);
      throw error;
    }
  }

  private buildPrompt(articles: TranslatedArticle[]): string {
    const today = getTodayPromptDate();

    let prompt = `Voc√™ √© um roteirista de podcast de not√≠cias de tecnologia. Crie um roteiro de podcast em portugu√™s do Brasil para dois apresentadores (uma mulher como apresentadora 1 e um homem como apresentador 2) que discutir√£o as not√≠cias mais recentes dos sites **TechCrunch e Gizmodo** de ${today}.

**INSTRU√á√ïES DE CONSOLIDA√á√ÉO:**
Analise as not√≠cias fornecidas abaixo. Se houver not√≠cias sobre o MESMO T√ìPICO ou T√ìPICOS MUITO RELACIONADOS (por exemplo, v√°rias not√≠cias sobre IA, lan√ßamentos de produtos da mesma empresa, ou regulamenta√ß√£o de criptomoedas), voc√™ deve **agrup√°-las** e discuti-las como um **√∫nico segmento** no roteiro. O objetivo √© criar uma discuss√£o coesa sobre o tema, em vez de discutir cada artigo individualmente.

**ESTRUTURA DO ROTEIRO:**

1.  **INTRODU√á√ÉO (30-45 segundos):**
    -   Os apresentadores d√£o as boas-vindas.
    -   Explicam que o epis√≥dio √© sobre as not√≠cias do dia dos sites TechCrunch e Gizmodo de ${today}.
    -   Tom descontra√≠do e amig√°vel.

2.  **DISCUSS√ÉO DOS T√ìPICOS CONSOLIDADOS:**
    -   Para cada t√≥pico consolidado (ou not√≠cia individual, se n√£o houver similaridade), os apresentadores alternam falas.
    -   O apresentador geralmente apresenta o t√≥pico, **incluindo os fatos mais relevantes e um breve hist√≥rico se necess√°rio.**
    -   O outro apresentador comenta e adiciona contexto/impacto, **aprofundando-se nos detalhes chave, nas implica√ß√µes para o mercado ou usu√°rios, e poss√≠veis desdobramentos futuros. Traga insights e uma an√°lise mais aprofundada baseada nas informa√ß√µes do conte√∫do fornecido.**
    -   A conversa deve ser din√¢mica, como dois amigos discutindo tecnologia.
    -   Cada segmento de discuss√£o (t√≥pico consolidado) deve ter 1-2 minutos de dura√ß√£o, **permitindo aprofundamento.**

3.  **ENCERRAMENTO (15-20 segundos):**
    -   Agradecimentos e convite para o pr√≥ximo epis√≥dio.

**ESTILO DA CONVERSA:**
-   Tom informal mas informativo.
-   Como dois amigos que entendem de tecnologia.
-   Usar express√µes brasileiras naturais.
-   Evitar linguagem muito t√©cnica.
-   Manter o interesse do ouvinte.

**NOT√çCIAS DO DIA:**

`;

    // Adicionar cada not√≠cia ao prompt (aqui elas ainda est√£o separadas, mas a instru√ß√£o acima pede a consolida√ß√£o)
    articles.forEach((article, index) => {
      prompt += `---
NOT√çCIA ${index + 1}:
T√≠tulo: ${article.tituloTraduzido}
Conte√∫do: ${article.conteudoTraduzido}
Data: ${article.dataPublicacao}
---

`;
    });

    prompt += `**FORMATO DE SA√çDA ESPERADO:**

Apresentador 1: Ol√°, pessoal! Sejam muito bem-vindos ao nosso bate-papo di√°rio sobre tecnologia!
Apresentador 2: √â isso mesmo! E hoje vamos mergulhar nas not√≠cias mais quentes do dia, direto dos sites TechCrunch e Gizmodo de ${today}.
Apresentador 1: Para come√ßar, temos um t√≥pico super interessante sobre [T√ìPICO CONSOLIDADO 1 - apresente o b√°sico da not√≠cia, os fatos centrais]. O que voc√™ achou disso?
Apresentador 2: Essa √© realmente fascinante! [COMENT√ÅRIO SOBRE O T√ìPICO 1, INCLUINDO DETALHES IMPORTANTES DAS NOT√çCIAS RELACIONADAS, IMPLICA√á√ïES, E UMA AN√ÅLISE MAIS APROFUNDADA. EX: 'O que me chamou a aten√ß√£o foi AQUELE DETALHE ESPEC√çFICO que o artigo mencionou...' ou 'Isso pode significar X para o mercado por causa de Y...']!
Apresentador 1: Sim, e isso pode significar [CONSEQU√äNCIA/AN√ÅLISE ADICIONAL baseada em detalhes]. Agora vamos para a pr√≥xima...
Apresentador 2: [T√ìPICO CONSOLIDADO 2 - apresente os fatos centrais da not√≠cia/t√≥pico]. Essa tamb√©m √© uma que promete bastante...
[... continuar para todos os t√≥picos/not√≠cias, garantindo mais detalhes e an√°lises nas falas dos apresentadores ...]

Apresentador 1: Bom, por hoje √© s√≥, pessoal!
Apresentador 2: Exato! N√£o esque√ßam de nos acompanhar amanh√£ para mais novidades do mundo da tecnologia!
Apresentador 1: At√© l√°!
Apresentador 2: Tchau, tchau!

**INSTRU√á√ïES FINAIS:**
-   Mantenha o formato exato com "Apresentador 1:" e "Apresentador 2:" no in√≠cio de cada fala.
-   **Certifique-se de que cada apresentador traga informa√ß√µes detalhadas e insights aprofundados sobre o t√≥pico discutido, n√£o apenas um resumo superficial.**
-   N√£o use marcadores ou numera√ß√£o na parte do di√°logo.
-   Fa√ßa a conversa fluir naturalmente.
-   Inclua TODAS as not√≠cias fornecidas, mas agrupadas por tema quando apropriado.
-   Mantenha o tom descontra√≠do e envolvente.
-   A sa√≠da deve ser texto puro, sem formata√ß√£o Markdown adicional para o roteiro final.
`;

    return prompt;
  }

  private async generatePodcastScript(prompt: string): Promise<string> {
    try {
      console.log('ü§ñ Gerando roteiro de podcast com Gemini...');
      
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();
      
      console.log('‚úÖ Roteiro gerado com sucesso!');
      return text;
    } catch (error) {
      console.error('‚ùå Erro ao gerar roteiro:', error);
      throw error;
    }
  }

  private async savePodcastScript(script: string): Promise<void> {
    try {
      const today = getTodayISODate();
      const fileName = `roteiro_podcast_${today}.txt`;
      const outputPath = path.join(process.cwd(), 'output', 'roteiro', fileName);
      
      // Criar diret√≥rio se n√£o existir
      const outputDir = path.dirname(outputPath);
      await fs.mkdir(outputDir, { recursive: true });
      
      console.log(`üíæ Salvando roteiro em: ${outputPath}`);
      
      const header = `ROTEIRO DE PODCAST - TECHCRUNCH
Data: ${new Date().toLocaleDateString('pt-BR')}
Gerado automaticamente com Gemini AI
=====================================

`;
      
      await fs.writeFile(outputPath, header + script, 'utf-8');
      console.log(`‚úÖ Roteiro salvo com sucesso!`);
    } catch (error) {
      console.error('‚ùå Erro ao salvar roteiro:', error);
      throw error;
    }
  }

  public async generatePodcast(): Promise<void> {
    try {
      console.log('üéôÔ∏è Iniciando gera√ß√£o de roteiro de podcast...');
      await sendTelegramMessage('üéôÔ∏è Iniciando gera√ß√£o de roteiro de podcast...');
      // Carregar artigos traduzidos
      const articles = await this.loadArticles();
      
      if (articles.length === 0) {
        console.log('‚ö†Ô∏è Nenhum artigo traduzido encontrado. Execute o tradutor primeiro.');
        return;
      }

      console.log(`üì∞ Processando ${articles.length} not√≠cias...`);
      
      // Construir prompt
      const prompt = this.buildPrompt(articles);
      
      // Gerar roteiro
      const script = await this.generatePodcastScript(prompt);
      
      // Salvar roteiro
      await this.savePodcastScript(script);
      
      console.log('\nüéâ Roteiro de podcast gerado com sucesso!');
      console.log('üìÅ Arquivo salvo como: roteiro_podcast_YYYY-MM-DD.txt');
      await sendTelegramMessage('üéâ Roteiro de podcast gerado com sucesso!');
    } catch (error) {
      console.error('‚ùå Erro durante a gera√ß√£o do podcast:', error);
      await sendTelegramMessage(`‚ùå Erro durante a gera√ß√£o do podcast: ${error}`);
      throw error;
    }
  }
}

export { PodcastGenerator };